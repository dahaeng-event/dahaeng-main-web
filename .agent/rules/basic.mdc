---
alwaysApply: true
---

## Names

- Variable names **clearly describe** what they represent.
- Function names **accurately convey** what the function does.
- The overall logic should be understandable from the names alone.
- **Functions:** use the **Verb + Noun** pattern (e.g., calculateColumnWidth, fetchUserData).
- **Consistency** is key — follow the same naming style across files.
- Avoid abbreviations unless standard (id, URL, API).
- **Booleans:** phrased as questions (isOpen, hasError, shouldUpdate).
- **Collections:** pluralized (users, items).
- Use **domain-specific** terms (cursorRule > dataConfig).
- **TypeScript naming:**
  - interface and type use **PascalCase** → UserProfile, CursorRule.
  - Variables and functions use **camelCase** → userProfile, applyCursorRule.

## File & Folder Names

- **Components:** PascalCase — UserCard.tsx.
- **Hooks:** useXxx.ts — useDebouncedValue.ts.
- **Utilities:** camelCase or kebab-case — cursorUtils.ts, date-utils.ts.
- **Constants:** use a dedicated file if shared — constants/cursor.ts.
- **Tests:** colocate with source — UserCard.test.tsx.

## Numbers & Constants (No Magic Numbers)

- Avoid inlining **magic numbers** for business logic or domain rules — define them as named constants at the top of the file.
- Use **UPPER_SNAKE_CASE** and meaningful names.
- **UI-only values are exempt:** layout, spacing, and size values used purely for styling (fixed widths/heights in JSX, or gap/spacing values) can stay inline without being extracted into constants.

## Reuse & Avoiding Duplicate Implementations

- Before adding a new function, schema, or type that models a domain concept, **scan the repository** for existing implementations with the same role or meaning.
- Prefer **reusing or extending** existing utilities, schemas, and components over creating a second, slightly different version of the same thing.
- When working in a file, **compare your planned changes against similar code elsewhere in the repo** to keep behavior and shapes consistent (e.g. validation rules, DTOs, API shapes).

**✔️ Do**

```ts
const DEFAULT_PAGE_SIZE = 20;

const paginate = (data: unknown[], page: number) => {
  return data.slice((page - 1) * DEFAULT_PAGE_SIZE, page * DEFAULT_PAGE_SIZE);
};
```

**❌ Don’t**

```ts
const paginate = (data: unknown[], page: number) => {
  return data.slice((page - 1) * 20, page * 20); // why 20?
};
```
