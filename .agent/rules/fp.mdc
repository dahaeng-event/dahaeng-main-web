---
alwaysApply: true
---

### Functional Programming Guidelines With FSD (Feature-Sliced Design) (Modern, Readable)

#### Core Principles

- Always use a functional programming style.
- Prefer pure functions: same inputs → same outputs; no hidden I/O or mutation.
- Use const for variables
  - Never use let.
- Declare functions as `const fn = (...) => ...`.
  - Try to keep principles of first class functions.
- Keep functions small and single-responsibility; compose instead of nesting.

#### Immutability

- Treat inputs as readonly; never mutate parameters or shared objects.
- Use spreads and non-mutating methods; avoid in-place ops (push/splice/sort/assign).
- Prefer `Readonly<T>` and `ReadonlyArray<T>` for APIs that should not mutate.

#### Data Transformation

- Favor declarative array methods: `map`, `filter`, `reduce`, `flatMap`, `some`, `every`.
- Avoid long chains; break pipelines into well-named steps for clarity.
- When sorting, copy first: `const sorted = [...items].sort(compare)`.

#### Composition and Naming

- Compose small helpers; export utilities that are generic and reusable.
- Prefer data-last parameter order for easy partial application when sensible.
- Name predicates with a question form (e.g., `isActive`), and transformers with verbs.

#### Types

- Precisely type inputs/outputs; avoid `any`. Use generics thoughtfully.
- Prefer discriminated unions over boolean flags or nullable fields.
- Model absence with explicit unions (`T | undefined`) and handle both branches.

#### Control Flow

- Use guard clauses to reduce nesting; return early on invalid states.
- Use exhaustive `switch` on discriminants; assert `never` on the default branch.
- Prefer expressions over statements when it improves readability.

#### Error Handling

- Keep pure layers free of throws; return typed results or unions where appropriate.
- Convert thrown errors to typed results at boundaries; log/side-effect only at edges.

#### Asynchrony

- Make async functions return `Promise<T>` and avoid shared mutable state.
- Prefer passing cancelation via `AbortSignal`; avoid fire-and-forget.
- Isolate retries/timeouts outside pure logic; keep transformation steps synchronous.

#### Prohibited/Discouraged

- Do not mutate inputs or shared module state.
- Avoid multi-purpose functions with optional behavior flags; split into focused APIs.
- Avoid clever one-liners when multiple named steps read better.

#### File Organization and Modularity

- Extract domain-specific complex pure functions into `features/${name}/utils` or `lib/${name}.ts`.
- Extract pure, reusable functions into dedicated utility modules under `shared/utils` or app-level `lib`.
  - Group by domain or operation (e.g., `date`, `array`, `string`, `reservation`).
  - Keep modules cohesive; avoid dumping unrelated helpers into grab-bag files.
- When files grow too long or mix concerns, split them.
  - Split by responsibility (types, pure logic, UI, hooks, API).
  - Aim for files that are skimmable; prefer <200–300 lines for day-to-day readability.
  - Move types to `types.ts` (or domain `types/`) and pure logic to `util/lib` files.
- Provide clear, small public surfaces via index files where appropriate.
