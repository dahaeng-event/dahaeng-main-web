---
globs: "*.{ts,tsx}"
alwaysApply: false
---

### Zustand Selector and Subscription Guidelines

#### Store Design

- Keep stores feature-scoped. Name hooks `useXxxStore` by domain.
- Store the minimal source of truth only. Keep derived/computed values outside the store as pure helpers.
- Keep state flat and serializable. Prefer IDs and maps over deeply nested objects.
- Separate state fields and action functions clearly; actions are the only writers.

#### Single Store Hook Call

- Use a single store hook call per component and select only the needed fields together.
- Always provide shallow equality for selector results to minimize re-renders.
  - Prefer `useShallow` to wrap selectors; return a stable plain object or tuple so shallow comparison is effective.
- Do not subscribe to the entire store state; it re-renders on any field change.
- Avoid multiple store hook calls for individual fields in the same component; it creates multiple subscriptions and scatters render triggers.
- Keep derived data outside the store in pure functions; select minimal raw state and derive in render or memoized helpers when necessary.

##### Preferred Pattern

```tsx
import { useShallow } from "zustand/react/shallow";

const { a, b } = useSomeStore(useShallow((s) => ({ a: s.a, b: s.b })));
```

##### Avoid

```tsx
// Multiple subscriptions in one component (avoid)
const a = useSomeStore((s) => s.a);
const b = useSomeStore((s) => s.b);

// Whole-store subscription (avoid) â€” any change triggers re-render
const state = useSomeStore();
const { a, b } = state;
```

##### Exceptions

- Only when fields change at very different frequencies and truly benefit from isolated re-renders may separate subscriptions be considered. Prefer splitting the component instead.

##### Additional Principles

- Ensure selector return shape and key order are stable across renders for reliable shallow equality.
- Maintain immutability in state updates and UI code; never mutate store state or objects returned from selectors.
