---
description: when using Tanstack query; useQuery, useMutation
alwaysApply: false
---

### TanStack Query v5 Guidelines

#### Core Rules

- Always handle both loading and error states explicitly in UI.
  - Use `isPending` for initial load.
  - Use `isError` for error state; render a clear message and a retry control.
  - Distinguish refetching from initial loading using `isFetching` and `isRefetching`.
- Do not rely on `data === undefined` to infer loading; use status flags.
- Use `const` and functional patterns; avoid side-effects in render.

#### Rendering Patterns

- Initial load:
  - If `isPending`, show skeleton/placeholder. Avoid blocking spinners across the whole page unless necessary.
- Error:
  - If `isError`, show an inline error UI with a `Retry` button that calls `refetch()`.
  - Keep error UI scoped to the affected area; do not crash the whole page unless critical.
- Refetch:
  - If `isFetching && !isPending`, keep prior data visible and show a lightweight progress affordance (subtle spinner/opacity) rather than replacing content.

Example:

```tsx
import { useQuery } from "@tanstack/react-query";

type User = { id: string; name: string };

export const Users = () => {
  const { data, isPending, isError, error, isFetching, refetch } = useQuery<
    User[]
  >({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  if (isPending) {
    return <UsersSkeleton />;
  }

  if (isError) {
    return (
      <ErrorPanel
        title="Failed to load users"
        description={(error as Error).message}
        onRetry={() => refetch()}
      />
    );
  }

  return (
    <div aria-busy={isFetching}>
      <UsersList users={data ?? []} />
    </div>
  );
};
```

#### Options and Defaults

- Use `select` to derive UI-friendly shapes inside the query, not in effects.

#### State

- Manage server state exclusively with TanStack Query (`useQuery`, `useMutation`); do not duplicate it in Zustand or other client stores.
- Use Zustand only for client/UI state (e.g., view toggles, transient input, local filters).
- For derived shapes of server data, prefer `select` or `setQueryData` on the query cache rather than copying data into another store.
- Prefer invalidation over manual cross-store synchronization; keep the query cache as the single source of truth.

#### Dependent Queries

- Gate dependent queries with `enabled` when required inputs are unavailable.
  - Example: `enabled: Boolean(userId)`.
- When an input becomes available, allow the query to fire automatically.

#### Mutations

- Use `isPending`, `isError`, and `isSuccess` from `useMutation` to drive button disabled states and feedback.
- Apply optimistic updates via cache when possible.
- Keep data manipulation (ex: setQueryData, invalidateQueries) in useMutation rather than components.
- Keep UI feedback (ex: toast, loading state) in components rather than useMutation.

Example:

```tsx
const queryClient = useQueryClient();

useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo, context) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await context.client.cancelQueries({ queryKey: ["todos"] });

    // Snapshot the previous value
    const previousTodos = context.client.getQueryData(["todos"]);

    // Optimistically update to the new value
    context.client.setQueryData(["todos"], (old) => [...old, newTodo]);

    // Return a result with the snapshotted value
    return { previousTodos };
  },
  // If the mutation fails,
  // use the result returned from onMutate to roll back
  onError: (err, newTodo, onMutateResult, context) => {
    context.client.setQueryData(["todos"], onMutateResult.previousTodos);
  },
  // Always refetch after error or success:
  onSettled: (data, error, variables, onMutateResult, context) =>
    context.client.invalidateQueries({ queryKey: ["todos"] }),
});
```

#### Prefer mutate over mutateAsync

- Prefer `mutate` by default and pass `onError`, `onSuccess`, and `onSettled` as per-call callbacks to `mutate`. Use `onMutate` in the hook options for optimistic updates.
- Avoid `mutateAsync` because it requires `try/catch/finally` in components and spreads control flow into UI code.

Preferred:

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();

const { mutate, isPending } = useMutation({
  mutationFn: saveItem,
  onSettled: () => queryClient.invalidateQueries({ queryKey: ["items"] }),
});

const onSubmit = (payload: ItemInput) => {
  mutate(payload, {
    onSuccess: () => toast.success("Saved"),
    onError: (err) => toast.error((err as Error).message),
  });
};
```

#### Do

- Use `isPending`/`isError` to branch UI states explicitly.
- Keep previous data visible during refetch; indicate progress subtly.
- Use `select`, `staleTime`, `gcTime`, and `enabled` intentionally.

#### Don’t

- Don’t infer status from `data` shape or truthiness.
- Don’t hide errors; always provide a retry path.
- Don’t block entire pages with spinners for localized queries.
- Don’t use `mutateAsync` in components; prefer `mutate` with callbacks.
